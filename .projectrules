# Development Best Practices for Indie Developers
# Version: 3.0 - Doctor Mode Focus + Optimization Lessons
# Last Updated: 2025-11-08
# Purpose: Quality-first development for indie devs, solo founders, and small teams
# Changelog: v3.0.0 optimization lessons (Phases 1-5) integrated
#
# Quick Links:
# - README: ../README.md
# - Market Positioning: docs/market-positioning.md
# - Rules Changelog: docs/rules-changelog.md

project_goals:
  - Ship fast: Optimize for quick iteration and deployment.
  - Quality by default: Automated testing, linting, CI/CD without manual setup.
  - Free-tier first: Optimize for GitHub free tier (2000 min/month Actions).
  - Solo-friendly: No team workflows, no approval gates, no complex processes.
  - Security baseline: No credentials in repo; dependency scanning included.
  - Keep it simple: If it slows you down, it's not worth it.

languages:
  - agnostic: Rules apply regardless of technology stack.
  - javascript: ES2020+ vanilla JS, modular assets/, no frameworks (if applicable).
  - typescript: Strict mode; ES2020 target; commonjs modules; declaration maps for debugging.
  - css: Utility-first, responsive design (if applicable).
  - json: Configuration, locales, and structured data (if applicable).

guardrails:
  - Secrets management: Never commit API keys, tokens, or credentials; use environment variables or secret stores.
  - Free-tier focus: Prefer free services (GitHub Actions, Vercel, Railway); document paid services if needed.
  - Testing standard: Unit tests for new features; keep tests fast; fix broken tests immediately.
  - Platform compatibility: Scripts should work on Windows/macOS/Linux; test on your target platform.
  - Security first: Automated dependency scanning; fail builds on critical vulnerabilities; keep dependencies updated.
  - Performance awareness: Don't ship obviously slow code; profile if users report issues.

code_style:
  - Documentation: Keep README and CONTRIBUTING aligned with current practices.
  - Version control: Conventional commits with scope; semantic versioning for releases.
  - Error handling: Graceful degradation; user feedback for failures.
  - State management: URL params for shareable states; secure storage for persistence.
  - Accessibility (if UI): Keyboard navigation, focus management, ARIA labels, semantic HTML.
  - Performance: Lazy loading, critical path optimization, resource hints (if applicable).
  - TypeScript adoption: Prefer TypeScript for core modules; strict mode enabled; compile to dist/; verify test imports use dist/ paths after compilation; create tests BEFORE implementing features when possible.
  - Post-compilation verification: After building TypeScript, run tests to verify all import paths resolve correctly to dist/ compiled output.
  - Type definitions: Create comprehensive interfaces in scripts/types/.
  - Backward compatibility: JavaScript wrappers for TypeScript modules during migration.
  - Code duplication: Use base classes and inheritance to eliminate duplicate code.
  - Union Type Exhaustiveness: Ensure TypeScript union types include all runtime values; add new values when code uses them.
  - Type-Driven Development: Let compile errors guide missing type definitions rather than runtime failures.

files:
  - Core governance: .projectrules, docs/rules-changelog.md - never modify without review.
  - CI/CD: .github/workflows/ - lint/test/governance stages.
  - Scripts: scripts/ - governance checks, budget tracking, cross-platform.
  - Documentation: README.md, CONTRIBUTING.md, docs/rules-changelog.md.
  - Testing: Unit tests required; integration/schema optional per project.

patterns:
  - Scope Gate: Required for new features/settings/external domains.
  - Optional Feature Retention: Remove unused features after 2 release cycles.
  - Performance Budgets: Define and track budgets; report-only to start.
  - Cycle Closeout: Post-cycle review checklist for continuous improvement.
  - Testing Strategy: Unit required; integration/schema optional; fast local loop.
  - Documentation Standards: Keep README/CONTRIBUTING current; changelog for rules evolution.
  - Structured Logging: Use createLogger() with context, levels (DEBUG/INFO/WARN/ERROR), JSON output for CI.
  - Base Class Pattern: Abstract base classes for shared logic; concrete implementations for specifics.
  - Factory Pattern: Registry pattern for instantiating implementations (e.g., package managers).
  - Inter-Tool Communication: Use structured markdown fields (**Field:** value) for machine parsing between tools.
  - Emoji Parsing: Use string.includes() and string.replace() for emoji detection; avoid regex character classes with multi-byte UTF-8.
  - Output Documentation: Document expected output formats in TypeScript interfaces when tools produce machine-readable reports.
  - Performance Metrics: Opt-in performance tracking with PerformanceTracker; use --performance flag for detailed reports.
  - Caching Strategy: Enable by default (--cache); content-based invalidation with SHA-256; 1-hour TTL for config cache.
  - Cache Optimization: FileCache for content hashing; ConfigCache for parsed configurations; transparent speedup.
  - Parallel Processing: Use Promise.all batching with concurrency control for I/O-bound operations; default to CPU count for concurrency.
  - Concurrency Control: Implement worker pools with max concurrency limits; track batch execution in performance metrics.
  - Memory Efficiency: Process items in chunks, not all at once; validate memory usage with 1000+ item tests.
  - Test-Driven Deletions: Before removing features: 1) Identify all references (grep), 2) Update/remove tests, 3) Verify tests pass/skip, 4) Delete feature code, 5) Remove dependencies, 6) Update docs.
  - Fixture Management: Before deleting fixtures: 1) Search all test files for fixture name, 2) Update or skip affected tests, 3) Verify tests pass, 4) Delete fixture directory, 5) Re-run full test suite.
  - Fixture References: Use constants for fixture paths; grep for fixture directory name before deletion; prefer smaller fixtures over large generated ones.

development_environment:
  - CI Node version: Standardize on Node 20.x LTS for all workflows (if applicable).
  - Error tracking: Document environment-specific errors and add to session reports.
  - Session reporting: At end of development sessions, include errors and workarounds in PR descriptions.
  - Platform testing: Test critical commands on target environment before implementation.
  - Command separation: Use individual terminal commands instead of chained commands.
  - Windows/PowerShell conventions: Use `;` not `&&` for command chaining; prefer `Get-ChildItem -Force` over `ls -la`; use `$env:VAR='value'` for environment variables; NEVER use emoji in commit messages (causes parse errors); escape special characters in strings.
  - Commit message safety: Avoid emoji, special characters, and complex formatting in commit messages; use plain ASCII for cross-platform compatibility; PowerShell parsing errors with UTF-8 emojis.
  - Git transport: Prefer HTTPS by default for push operations; SSH optional with explicit host key configuration.
  - Repo-root preflight: Before first commit, run `git rev-parse --show-toplevel` and ensure it equals the project directory; fix before committing if not.
  - Rules evolution: Update rules after each Plan→Agent cycle with new patterns and best practices.
  - Session review: After each cycle, complete checklist: summarize changes, log errors/workarounds, document rule deltas, bump version, update changelog, link in PR.
  - Build toolchain: npm run build compiles TypeScript; npm run build:watch for development.
  - Type checking: npm run prebuild validates types before building.
  - Log configuration: LOG_LEVEL and LOG_JSON environment variables for structured logging.
  - Windows test compatibility: Prefer os.tmpdir() over /tmp for temp directories; avoid mock-fs for cross-platform tests.
  - UTF-8 emoji handling: Use literal emoji strings in code; test emoji parsing with actual characters.
  - Performance tracking: Use --performance flag for rule timing, memory usage, and optimization recommendations.
  - Caching enabled: Config parsing cached by default; use --no-cache to disable; 2-3x speedup on repeated runs.
  - Terminal command timeouts: Always monitor terminal execution time; cancel stalled commands based on expected operation duration (see terminal_timeout_guidelines).

terminal_timeout_guidelines:
  - Quick operations (< 5 seconds): git status, git add, ls, cd, echo, simple file reads
  - Fast operations (5-15 seconds): npm install (with cache), git commit, git push (small changes), tsc --noEmit, linting
  - Medium operations (15-60 seconds): npm test (unit tests), npm run build, git clone (small repos)
  - Slow operations (1-3 minutes): npm test (integration tests), npm install (no cache), git push (large changes)
  - Very slow operations (3-10 minutes): npm test (full suite with E2E), large builds, CI workflows
  - Timeout policy: If command exceeds 2x expected duration, cancel and investigate; never wait indefinitely
  - Stall detection: If no output for 30 seconds on expected-fast operations, assume stall and cancel
  - Test execution: Unit tests should complete in < 10 seconds; integration tests < 60 seconds; cancel if exceeded
  - User notification: When canceling stalled commands, explain expected vs actual duration and next steps
  - Remediation: After timeout, identify root cause (slow tests, infinite loops, blocking I/O) and fix before retrying
  - Long operations warning: npm install without cache can take 60+ seconds; npm prune after major dep cleanup can take 30+ seconds; always check package count difference
  - Test execution after refactor: First test run after major deletions may be slower due to module resolution; subsequent runs should be fast

advanced_patterns:
  - Client-side filtering: URL synchronization for bookmarkable states (if applicable).
  - Progressive enhancement: Core functionality works without enhancements; enhanced with features.
  - Defensive programming: Safe fallbacks for missing data; graceful error handling.
  - Resource hints optimization: Strategic preconnect hints for external domains (if applicable).
  - Navigation announcements: Screen reader feedback for all navigation changes (if applicable).
  - JSON-LD testing: Comprehensive validation tests for structured data (if applicable).
  - Accessibility announcements: Comprehensive screen reader support for all user actions (if applicable).

accessibility:
  - WCAG AA compliance: 4.5:1 contrast ratio, 3:1 for large text (if user-facing UI).
  - Keyboard navigation: Tab order logical; Enter/Space activate controls.
  - Screen readers: ARIA labels, live regions, semantic HTML structure.
  - Focus management: Visible focus indicators, focus traps for modals.
  - Motion sensitivity: prefers-reduced-motion support (if applicable).
  - Color independence: No color-only information conveyance.
  - Error identification: Clear labels, descriptions, and suggestions.

performance:
  - Core Web Vitals (if web UI): LCP < 2.5s, CLS < 0.1, FID < 100ms targets.
  - Resource loading: Preconnect to external domains; preload critical assets.
  - Bundle optimization: Defer non-critical assets; tree-shake unused code.
  - Image optimization: Lazy loading, modern formats, proper dimensions (if applicable).
  - Build performance: Track and optimize build time; cache dependencies.
  - Critical path: Optimize loading of critical resources.

testing:
  - Unit tests: Core utilities/modules/components; required for new code.
  - Integration tests: Critical flows or interfaces; optional per project.
  - Schema/Contract: Validate structured config/data against schemas (if applicable).
  - Accessibility: Keyboard navigation, screen reader testing (if UI).
  - Performance: Track budgets and surface regressions in CI.
  - Cross-browser: Modern browser support (last 2 versions).
  - Error states: Network failures, missing data, invalid configurations.
  - Local development: Fast test loop; clear pass/fail feedback.
  - Compilation: Run tsc --noEmit before tests to catch type errors.
  - Test strategy: Import from compiled dist/ for backward compatibility.
  - Cross-platform test isolation: Use real temp directories (os.tmpdir + fs.mkdtemp) over mock-fs for Windows compatibility.
  - Test cleanup: Always use fs.rm with recursive:true and force:true in afterEach hooks.
  - Emoji handling in tests: Test with actual UTF-8 emoji characters, not ASCII approximations.
  - Test data generation: Generate fixtures from actual tool output, not assumed formats.
  - Format validation: Match test assertions to exact output format including markdown syntax.
  - Performance tests: Validate tracker accuracy, cache efficiency, and metric calculations.
  - Async test patterns: Use async/await in tests for time-based validations.
  - Parallel testing: Test concurrency limits, error handling, progress callbacks, and memory efficiency.
  - Large fixtures: Create 100+ file fixtures for performance testing; verify 2-3x speedup with parallel mode.
  - Test timeouts: All tests must have explicit timeouts; unit tests default 5s, integration 60s; use { timeout: ms } option.
  - Timeout enforcement: Remove or fix tests that consistently exceed timeouts; never increase timeouts to mask slow tests.
  - Test isolation: Each test should be independently runnable; avoid shared state that causes cascading failures.
  - Slow test remediation: Profile slow tests, cache expensive operations (schema compilation, fixture setup), or split into faster units.

review:
  - Pre-commit checks: Lint, tests pass; clear pass/fail signal.
  - Manual testing: Critical flows tested; screenshots for UI changes (if applicable).
  - Performance check: No significant regressions introduced.
  - Documentation: Update README for user-facing changes.
  - Test coverage: New features have tests; existing tests still pass.
  - Quick validation: Does it work? Is it tested? Is it documented?

contribution:
  - Branch naming: feat/, fix/, refactor/, perf/, docs/, test/, chore/ prefixes.
  - Commit messages: Conventional commits with scope (e.g., feat(auth): add login, fix(ui): resolve button focus).
  - PR requirements: Description, testing notes, screenshots for UI changes (if applicable).
  - Breaking changes: Document in commit message with migration notes.
  - Open source friendly: Clear descriptions, helpful for future contributors.

commits:
  - Format: type(scope): description
  - Types: feat, fix, refactor, perf, docs, test, chore
  - Scope: feature area (e.g., ui/button, api/auth, docs/readme)
  - Breaking changes: Add "BREAKING CHANGE:" footer with migration notes
  - Examples: "feat(auth): add login validation", "fix(ui): resolve button focus trap"

policies:
  - Testing Standard: Unit tests for new features; integration tests optional; keep tests fast (< 5s unit, < 60s integration).
  - Security Baseline: No credentials in repo; automated dependency scanning; fail builds on critical vulnerabilities.
  - Free-Tier First: Optimize CI for GitHub Actions free tier (< 2000 min/month); cache dependencies; parallel where beneficial.
  - Performance Awareness: Track build times; report slow tests; optimize bottlenecks as they appear.
  - Git Best Practices: Conventional commits (feat/fix/docs); HTTPS for push; clear commit messages.
  - Quality Checks: Automated linting, type checking, and testing on every push; fix before merge.
  - Keep It Working: Main branch should always be deployable; fix broken builds immediately.
  - Documentation: Update README for user-facing changes; keep docs simple and actionable.
  - Dependency Management: Review deps before adding; prefer standard library; keep dependencies minimal and updated.

version_control:
  - Rules versioning: Update version number in header for major changes and phase completions.
  - Change documentation: Document rule modifications in commit messages.
  - Backwards compatibility: Avoid breaking changes; use deprecation warnings.
  - Migration guide: Update docs when rules change significantly.
  - Error integration: Incorporate documented errors into rules for continuous improvement.
  - Environment updates: Add platform-specific workarounds and compatibility notes.
  - Pattern documentation: Update patterns section when new architectural patterns emerge.
  - Session-driven updates: Review each development session and update rules with new optimizations.
  - Advanced practices: Add advanced_patterns section for complex implementation strategies.
  - Cycle closeout: Formal post-cycle review process to maintain standards evolution.

large_scale_refactoring:
  - Pre-refactor checklist: Full test suite passing; all tests have timeouts; clear rollback plan.
  - Incremental approach: Test after each major subsection (e.g., every 10-20 file deletions).
  - Dependency cleanup first: Remove unused deps before removing code to avoid carrying dead weight.
  - Feature deletion order: Tests → Code → Dependencies → Documentation (reverse of creation).
  - Version bumping: Major version for breaking changes; document all removals in BREAKING CHANGE.
  - Fixture validation: Grep for fixture references before deletion; update tests first.
  - Import path verification: After TypeScript compilation, verify test imports from dist/.
  - Commit granularity: One logical change per commit; easier rollback and review.
  - Documentation sync: Update docs immediately after removing features, not at end.

optimization_workflow:
  - Phase planning: Break large changes into 5-7 phases max; each phase should be independently testable.
  - Phase boundaries: Test, commit, and push after each phase completion; tag major milestones.
  - Rollback readiness: Each phase should be independently revertable without breaking functionality.
  - Dependency timing: Clean up unused dependencies in first phase, not last.
  - Documentation timing: Update user-facing docs during relevant phase, not deferred to end.
  - Test suite health: Maintain passing tests throughout; never proceed with failing tests.
  - Incremental validation: Build and test after every major change (10-20 files or key feature).

cycle_closeout:
  - Quick Review: Before merging, verify:
    - [ ] Changes work as expected
    - [ ] Tests pass
    - [ ] Docs updated (if user-facing change)
    - [ ] No secrets committed
    - [ ] Build/deploy still works
  - That's it! Keep it simple.
