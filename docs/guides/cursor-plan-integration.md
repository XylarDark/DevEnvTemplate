# Cursor Plan Integration

This guide shows how DevEnvTemplate integrates with Cursor Plan mode to create a Plan-first development workflow where CI automation handles the heavy lifting.

## Overview

DevEnvTemplate turns Cursor Plan mode into your primary development interface:

- **Drop-in Intelligence**: Automatically understands your tech stack
- **CI-Generated Artifacts**: Stack reports and gap analysis for context
- **Plan-First Enforcement**: CI validates that code changes follow approved plans
- **Impact Validation**: Ensures actual changes match plan predictions

**No local commands required** - everything flows through Cursor Plan mode and CI.

## Workflow

### Phase 1: CI Detects Stack & Gaps

When you drop DevEnvTemplate into your repository:

1. **Push the changes** - CI automatically runs stack analysis
2. **CI posts PR comment** with detected technologies and improvement recommendations
3. **CI generates artifacts**:
   - `.devenv/stack-report.json` - Your technology stack
   - `.devenv/gaps-report.md` - Areas for improvement

### Phase 2: Plan with Cursor (Using CI Artifacts)

**Use Cursor Plan mode as your primary planning tool:**

1. **Open Plan Mode** (`Cmd/Ctrl + Shift + P` â†’ "Plan Mode")
2. **Attach CI artifacts** for comprehensive context:
   - Download `.devenv/stack-report.json` from CI artifacts
   - Download `.devenv/gaps-report.md` from CI artifacts

3. **Use Plan snippets** from `docs/snippets/plan-mode/` as templates

**Example Plan Mode input:**

```
I need to implement [FEATURE NAME].

PROJECT CONTEXT (from CI artifacts):
- Tech Stack: [paste contents of .devenv/stack-report.json]
- Current Gaps: [paste relevant sections from .devenv/gaps-report.md]

REQUIREMENTS:
- Follow DevEnvTemplate patterns from docs/engineering-handbook.md
- Address gaps identified in CI analysis
- Include comprehensive error handling and TypeScript types
- Write tests for new functionality
- Ensure code quality gates pass

Create a detailed implementation plan with:
1. Task breakdown (single-responsibility tasks)
2. File changes needed with specific paths
3. Testing strategy
4. Rollback plan
5. Success metrics
```

### Phase 3: Submit Plan-Only PR

1. **Create Plan-Only PR** using `.github/PULL_REQUEST_TEMPLATE/plan-only.md`
2. **Include plan artifacts** generated by Cursor Plan mode
3. **Get stakeholder approval** before implementing any code

### Phase 4: Execute Implementation

1. **Implement code** following the approved plan
2. **Use Cursor** for AI-assisted coding
3. **CI validates** changes match plan predictions
4. **Quality gates** ensure code standards

### Phase 5: CI Validation

**CI automatically validates:**
- Plan-only PR approval exists for code changes
- Actual file changes match impact predictions
- Quality gates pass (lint, test, security)

## Plan Mode Snippets

Use these ready-made snippets from `docs/snippets/plan-mode/`:

### For New Features
```
Based on CI stack analysis, implement [FEATURE] that addresses [GAP].

PROJECT CONTEXT:
Tech Stack: [contents of .devenv/stack-report.json]
Gaps to Address: [relevant sections from .devenv/gaps-report.md]

Create implementation plan with specific file paths and testing strategy.
```

### For Improvements
```
Improve [AREA] based on CI gap analysis.

CURRENT STATE: [from .devenv/stack-report.json]
GAPS IDENTIFIED: [from .devenv/gaps-report.md]

Plan specific changes to address high-priority gaps.
```

### For Refactoring
```
Refactor [COMPONENT] following DevEnvTemplate patterns.

TECHNICAL CONTEXT: [relevant stack info]
QUALITY GOALS: [from gap analysis]

Plan modular improvements with testing coverage.
```

## CI Integration

### Stack Intelligence Workflow

The `stack-intel.yml` workflow automatically:

- **Detects technologies** (Node.js, React, TypeScript, testing frameworks)
- **Analyzes configurations** (linting, CI, security)
- **Identifies gaps** against DevEnvTemplate standards
- **Posts PR comments** with findings and next steps

### Plan/Agent Guard

The `plan-agent-guard` job enforces:

- **Plan-Only Gate**: Requires plan approval for code changes
- **Impact Validation**: Compares actual vs. predicted changes
- **Context Validation**: Ensures complete requirements
- **PR Comments**: Provides validation status

## Configuration

### Repository Variables

Control enforcement levels via GitHub repository variables:

- `STRICT_PLAN_GUARD=true` - Require plan-only PRs
- `IMPACT_GUARD=warn|strict` - Impact validation level

### Default Behavior

- Stack analysis always runs and posts comments
- Plan guard disabled by default (enable with `STRICT_PLAN_GUARD=true`)
- Impact validation disabled by default (enable with `IMPACT_GUARD=warn`)

## Best Practices

### Plan Creation
- Always attach CI artifacts (stack report + gaps) for context
- Use specific file paths in plans (not "update files")
- Include testing strategy for each task
- Define success metrics upfront

### Implementation
- Follow plan exactly - CI validates alignment
- Run quality gates frequently during development
- Address CI feedback immediately
- Document deviations from plan (if any)

### Review Process
- Plan-only PRs get stakeholder approval
- Implementation PRs validated by CI
- Use PR templates for consistent process
- Link implementation PRs to approved plans

## Troubleshooting

### CI Not Detecting Stack
- Ensure package.json exists with proper dependencies
- Check that DevEnvTemplate folder is in repository root
- Verify CI has read access to source files

### Plan Validation Failing
- Ensure plan-only PR was merged before implementation
- Check that file changes match plan predictions
- Verify PR title/body references the plan

### Impact Analysis Issues
- Update context contract with accurate impact predictions
- Include all affected files in plan
- Explain any deviations from predictions
